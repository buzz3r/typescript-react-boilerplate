///<reference path="node_modules/typescript/bin/typescript.d.ts" />
///<reference path="node_modules/typescript/bin/typescript_internal.d.ts" />
///<reference path="node_modules/typescript/bin/typescriptServices.d.ts" />
///<reference path="typings/node/node.d.ts" />
///<reference path="typings/loaderUtils/loaderUtils.d.ts" />
///<reference path="typings/objectAssign/objectAssign.d.ts" />
///<reference path="typings/colors/colors.d.ts" />
var typescript = require('typescript');
var path = require('path');
var fs = require('fs');
var os = require('os');
var loaderUtils = require('loader-utils');
var objectAssign = require('object-assign');
require('colors');
var instances = {};
function consoleError(msg) {
    setTimeout(function () { return console.log('ERROR' + os.EOL + msg); }, 0);
}
function handleErrors(diagnostics, outputFn) {
    diagnostics.forEach(function (diagnostic) {
        if (diagnostic.file) {
            var lineChar = diagnostic.file.getLineAndCharacterFromPosition(diagnostic.start);
            outputFn("  " + diagnostic.file.filename.blue + " (" + lineChar.line.toString().cyan + "," + lineChar.character.toString().cyan + "): " + diagnostic.messageText.red);
        }
        else {
            outputFn("  " + "unknown file".blue + ": " + diagnostic.messageText.red);
        }
    });
}
function ensureTypeScriptInstance(options, loader) {
    var compiler = require(options.compiler);
    var files = {};
    if (Object.prototype.hasOwnProperty.call(instances, options.instance)) {
        var instance = instances[options.instance];
        files = instance.files;
        options.additionalFiles.forEach(function (filePath) {
            if (!Object.prototype.hasOwnProperty.call(options.additionalFiles, filePath)) {
                files[filePath] = {
                    text: fs.readFileSync(filePath, 'utf-8'),
                    version: 0
                };
            }
        });
        return instance;
    }
    var target;
    switch (options.target) {
        case "ES3":
            target = 0 /* ES3 */;
            break;
        case "ES6":
            target = 2 /* ES6 */;
            break;
        default: target = 1 /* ES5 */;
    }
    var compilerOptions = {
        target: target,
        module: options.module == "AMD" ? 2 /* AMD */ : 1 /* CommonJS */,
        sourceMap: !!options.sourceMap,
        noImplicitAny: !!options.noImplicitAny
    };
    options.additionalFiles.push(path.join(path.dirname(require.resolve('typescript')), 'lib.d.ts'));
    options.additionalFiles.forEach(function (filePath) {
        files[filePath] = {
            text: fs.readFileSync(filePath, 'utf-8'),
            version: 0
        };
    });
    var servicesHost = {
        getScriptFileNames: function () { return Object.keys(files); },
        getScriptVersion: function (filename) { return files[filename] && files[filename].version.toString(); },
        getScriptSnapshot: function (filename) {
            var file = files[filename];
            return {
                getText: function (start, end) { return file.text.substring(start, end); },
                getLength: function () { return file.text.length; },
                getLineStartPositions: function () { return []; },
                getChangeRange: function (oldSnapshot) { return undefined; }
            };
        },
        getCurrentDirectory: function () { return process.cwd(); },
        getScriptIsOpen: function () { return true; },
        getCompilationSettings: function () { return compilerOptions; },
        getDefaultLibFilename: function (options) { return 'lib.d.ts'; },
        // getNewLine() should work in next version of TypeScript
        // see https://github.com/Microsoft/TypeScript/issues/1653
        //getNewLine: () => { return os.EOL },
        log: function (message) { return console.log(message); }
    };
    var languageService = compiler.createLanguageService(servicesHost, compiler.createDocumentRegistry());
    var instance = instances[options.instance] = {
        compiler: compiler,
        compilerOptions: compilerOptions,
        files: files,
        languageService: languageService
    };
    handleErrors(languageService.getCompilerOptionsDiagnostics(), consoleError);
    // handle errors for all declaration files at the end of each compilation
    loader._compiler.plugin("done", function (stats) {
        Object.keys(instance.files).filter(function (filePath) { return !!filePath.match(/\.d\.ts$/); }).forEach(function (filePath) {
            handleErrors(languageService.getSyntacticDiagnostics(filePath).concat(languageService.getSemanticDiagnostics(filePath)), consoleError);
        });
    });
    // manually update changed declaration files
    loader._compiler.plugin("watch-run", function (watching, cb) {
        var mtimes = watching.compiler.watchFileSystem.watcher.mtimes;
        Object.keys(mtimes).filter(function (filePath) { return !!filePath.match(/\.d\.ts$/); }).forEach(function (filePath) {
            filePath = path.normalize(filePath);
            var file = instance.files[filePath];
            if (file) {
                file.text = fs.readFileSync(filePath, { encoding: 'utf8' });
                file.version++;
            }
        });
        cb();
    });
    return instance;
}
function loader(contents) {
    var _this = this;
    this.cacheable && this.cacheable();
    var callback = this.async();
    var filePath = path.normalize(this.resourcePath);
    var options = loaderUtils.parseQuery(this.query);
    options = objectAssign({}, {
        instance: 'default',
        compiler: 'typescript',
        sourceMap: false,
        additionalFiles: []
    }, options);
    options.additionalFiles = options.additionalFiles.map(function (filePath) { return path.resolve(_this.context, filePath); });
    var instance = ensureTypeScriptInstance(options, this);
    if (!Object.prototype.hasOwnProperty.call(instance.files, filePath)) {
        var filePaths = Object.keys(instance.files);
        filePaths.push(filePath);
        var program = instance.compiler.createProgram(filePaths, instance.compilerOptions, instance.compiler.createCompilerHost(instance.compilerOptions));
        program.getSourceFiles().forEach(function (file) {
            var filePath = path.normalize(file.filename);
            if (!Object.prototype.hasOwnProperty.call(instance.files, filePath)) {
                instance.files[filePath] = { version: 0, text: file.text };
            }
        });
    }
    var file = instance.files[filePath], langService = instance.languageService;
    file.text = contents;
    file.version++;
    this.clearDependencies();
    this.addDependency(filePath);
    Object.keys(instance.files).filter(function (filePath) { return !!filePath.match(/\.d\.ts$/); }).forEach(this.addDependency.bind(this));
    var output = langService.getEmitOutput(filePath);
    handleErrors(langService.getSyntacticDiagnostics(filePath).concat(langService.getSemanticDiagnostics(filePath)), this.emitError.bind(this));
    if (output.outputFiles.length == 0)
        throw new Error("Typescript emitted no output for " + filePath);
    var sourceMap;
    if (options.sourceMap) {
        sourceMap = JSON.parse(output.outputFiles[0].text);
        sourceMap.sources = [loaderUtils.getRemainingRequest(this)];
        sourceMap.file = loaderUtils.getCurrentRequest(this);
        sourceMap.sourcesContent = [contents];
        contents = output.outputFiles[1].text.replace(/^\/\/# sourceMappingURL=[^\r\n]*/gm, '');
    }
    else {
        contents = output.outputFiles[0].text;
    }
    contents = contents.replace(/\r\n/g, os.EOL);
    callback(null, contents, sourceMap);
}
module.exports = loader;
